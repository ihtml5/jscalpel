{"version":3,"file":"jscalpel.min.js","sources":["../index.js"],"sourcesContent":["const nativeToString = Object.prototype.toString;\r\nconst isObject = (path) => nativeToString.call(path) === '[object Object]';\r\n\r\n\r\nclass JscalpelCore {\r\n    constructor({\r\n        target,\r\n        returnedValue,\r\n        error\r\n    }) {\r\n        this._target = target;\r\n        this._error = error;\r\n        this._returnedValue = returnedValue;\r\n    }\r\n\r\n    _getValueByPath (path) {\r\n        let result = null;\r\n        let epTarget = this._target;\r\n        let keyPaths = this._fallbackpath(path).split('.')\r\n        for (let i = 0, len = keyPaths.length; i < len; i++) {\r\n          result = result ? result[keyPaths[i]] : epTarget[keyPaths[i]];\r\n          if (typeof result === undefined) {\r\n              return result;\r\n          }\r\n        }\r\n        return result\r\n    }\r\n    _getValue (path) {\r\n        let result = null;\r\n        let epTarget = this._target;\r\n        let pResult = [];\r\n        let self = this;\r\n        if (typeof path === 'string' && path.length > 0) {\r\n            return this._getValueByPath(path);\r\n        } else if (nativeToString.call(path) === '[object Array]') {\r\n            path.forEach((singlePath, idx) => {\r\n                if (typeof singlePath === 'string') {\r\n                    result = self._getValueByPath(singlePath);\r\n                    pResult.push(result);\r\n                }\r\n            })\r\n            if (pResult.length === 0) {\r\n                return null;\r\n            }\r\n            return pResult;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    get (path) {\r\n        return path ? this._getValueByPath(path) : this._returnedValue;\r\n    }\r\n    _fallbackpath (path) {\r\n        if (typeof path !== 'string') {\r\n            return '';\r\n        }\r\n        return path;\r\n    }\r\n\r\n    // 扩展和设置值\r\n    _extend (ns, ns_string, ...rest) {\r\n        if (isObject(ns)) {\r\n            var current = ns;\r\n            var parts = ns_string.split('.');\r\n            var pl = parts.length;\r\n            for (let i = 0; i<pl; i++) {\r\n                if (typeof current[parts[i]] === 'undefined') {\r\n                    current[parts[i]] = {};\r\n                }\r\n                if (rest.length>0 && (i === pl-1)) {\r\n                    current = current[parts[i]] = rest[0];\r\n                } else {\r\n                    current = current[parts[i]];\r\n                }\r\n\r\n            } \r\n        }\r\n    }\r\n    _setOrDel (path, value) {\r\n        let fallbackPath = this._fallbackpath(path);\r\n        if (fallbackPath === '') {\r\n            if (typeof this._error === 'function') {\r\n                this._error(this._target, path);\r\n            }\r\n            return;\r\n        }\r\n        this._extend(this._target, fallbackPath, value);\r\n    }\r\n    set (path, value) {\r\n        if (isObject(path)) {\r\n            Object.keys(path).forEach((key, index) => {\r\n                this._setOrDel(key, path[key]);\r\n            })\r\n        } else {\r\n            this._setOrDel(path, value);\r\n        }\r\n    }\r\n\r\n    has (path) {\r\n       let returnedValue = this._getValueByPath(path);\r\n       if (!returnedValue) {\r\n           return false;\r\n       }\r\n       return true;\r\n    }\r\n\r\n    del(path) {\r\n        let self = this;\r\n        if (!path) {\r\n            return;\r\n        }\r\n        if (Array.isArray(path)) {\r\n            path.forEach((ph, index) => {\r\n                self._setOrDel(ph, void 0);\r\n            })\r\n        } else {\r\n            self._setOrDel(ph, void 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nconst jscalpel = ({ target, path, keys, prefix, callback, success, deep, plugins, error}, defaultOpts) => {\r\n    const compatCb = success || callback;\r\n    const enablePrefix = prefix ? true : false;\r\n    const deepCopy = (obj) => {\r\n        const returnObj = {};\r\n        let tempArr = [];\r\n        if (nativeToString.call(obj) === '[object Object]') {\r\n            Object.keys(obj).forEach((path, index) => {\r\n                if (Array.isArray(obj[path])) {\r\n                    obj[path].forEach((value, index) => {\r\n                        tempArr.push(value);\r\n                    });\r\n                    returnObj[path] = tempArr;\r\n                    tempArr = [];\r\n                } else if (nativeToString.call(obj[path] === '[object Object]')) {\r\n                    returnObj[path] = deepCopy(obj[path]);\r\n                }\r\n            });\r\n            return returnObj;\r\n        } else {\r\n            return obj;\r\n        }\r\n    }\r\n\r\n    const autoCompletePath = (path) => {\r\n        return (`${prefix && enablePrefix ? `${prefix}.${path}` : `${path}`}`);\r\n    }\r\n\r\n    const getValueByPath = function ({path, target, plugins, index}) {\r\n        let result = target\r\n        let parseingPaths = (autoCompletePath(path)).split('.')\r\n        for (let i = 0, len = parseingPaths.length; i < len; i++) {\r\n          result = result[parseingPaths[i]]\r\n          if (result === undefined) {\r\n              return result;\r\n          }\r\n        }\r\n        return result\r\n      }\r\n    \r\n      const executePlugins = ({ plugins, name, value }) => {\r\n          let willPluginInfo = {\r\n              value,\r\n              name\r\n          }\r\n          if (plugins && Array.isArray(plugins) && plugins.length) {\r\n            plugins.forEach((plugin, index) => {\r\n                plugin(willPluginInfo);\r\n            });\r\n          }\r\n\r\n      } \r\n    const getParameterNames = (fn) => {\r\n        const COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\n        const DEFAULT_PARAMS = /=[^,]+/mg;\r\n        const FAT_ARROWS = /=>.*$/mg;\r\n        const code = fn.toString()\r\n            .replace(COMMENTS, '')\r\n            .replace(FAT_ARROWS, '')\r\n            .replace(DEFAULT_PARAMS, '');\r\n\r\n        const result = code.slice(code.indexOf('(') + 1, code.indexOf(')'))\r\n            .match(/([^\\s,]+)/g);\r\n\r\n        return result === null\r\n            ? []\r\n            : result;\r\n    }\r\n\r\n    const getReturnedVal = (defaultValue, result, pResult) => {\r\n        if (typeof value !== 'undefined') {\r\n            return value;\r\n        } else {\r\n            return result || pResult;\r\n        }\r\n    }\r\n    //  try transform anything to object\r\n    const transformAnyToObj = (target) => {\r\n        let epTarget  = null;\r\n        try {\r\n            epTarget = typeof target === 'string' ? JSON.parse(target) : target;\r\n            if (deep) {\r\n                epTarget = deepCopy(epTarget);\r\n            }\r\n    \r\n            if (nativeToString.call(epTarget) !== '[object Object]' && !Array.isArray(epTarget)) {\r\n                typeof error === 'function' && error(epTarget);\r\n                return;\r\n            }\r\n        } catch (err) {\r\n            typeof error === 'function' && error(epTarget, err);\r\n            return;\r\n        }\r\n        return epTarget;\r\n    }\r\n\r\n    let defaultValue = null;\r\n    let result = null;\r\n    let willPluginInfo = {};\r\n    let epTarget = transformAnyToObj(target);\r\n    let pResult = [];\r\n    let cbParams = compatCb ? getParameterNames(compatCb) : [];\r\n    path = typeof path === 'function' ? path(prefix) : ( path || keys);\r\n\r\n\r\n    if (typeof path === 'string' && path.length > 0) {\r\n        result = getValueByPath({path, target});\r\n        executePlugins({plugins, name: cbParams[0], value: result});\r\n        if (compatCb && typeof compatCb === 'function') {;\r\n            defaultValue = compatCb.call(null, result, epTarget, path, defaultOpts);\r\n        } else {\r\n            defaultValue = compatCb;\r\n        }\r\n    } else if (nativeToString.call(path) === '[object Array]') {\r\n        path.forEach((singlePath, idx) => {\r\n            if (typeof singlePath === 'string') {\r\n                result = getValueByPath({path: singlePath, target});\r\n                executePlugins({plugins, value: result, name: cbParams[idx]});\r\n                pResult.push(result);\r\n            }\r\n            result = null;\r\n        })\r\n        pResult.push(epTarget, path, defaultOpts);\r\n        if (compatCb && typeof compatCb === 'function') {\r\n            defaultValue = compatCb.apply(null, pResult);\r\n        } else {\r\n            defaultValue = compatCb;\r\n        }\r\n    }\r\n    if (typeof callback === 'function' || typeof success === 'function') {\r\n        return getReturnedVal(defaultValue, result, pResult.slice(0,-3));\r\n    }\r\n    return new JscalpelCore({\r\n        target: epTarget,\r\n        error\r\n    })\r\n}\r\n\r\nexport default jscalpel;"],"names":["nativeToString","Object","prototype","toString","isObject","path","call","JscalpelCore","target","returnedValue","error","_target","_error","_returnedValue","result","epTarget","this","keyPaths","_fallbackpath","split","i","len","length","undefined","pResult","self","_getValueByPath","forEach","singlePath","idx","push","ns","ns_string","current","parts","pl","value","fallbackPath","_extend","keys","key","index","_setOrDel","Array","isArray","ph","defaultOpts","prefix","callback","success","deep","plugins","compatCb","enablePrefix","deepCopy","obj","returnObj","tempArr","autoCompletePath","getValueByPath","parseingPaths","executePlugins","name","willPluginInfo","plugin","JSON","parse","err","transformAnyToObj","cbParams","fn","COMMENTS","DEFAULT_PARAMS","FAT_ARROWS","code","replace","slice","indexOf","match","getParameterNames","apply","defaultValue","getReturnedVal"],"mappings":"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"}