{"version":3,"file":"jscalpel.min.js","sources":["../index.js","../plugins/jscalpeltype.js","../plugins/jscalpellogic.js"],"sourcesContent":["import jscalpelType from './plugins/jscalpeltype';\r\nimport jscalpelLogic from './plugins/jscalpellogic';\r\n\r\nconst nativeToString = Object.prototype.toString;\r\nconst isObject = (path) => nativeToString.call(path) === '[object Object]';\r\n\r\n\r\nclass JscalpelCore {\r\n    constructor({\r\n        target,\r\n        returnedValue,\r\n        error\r\n    }) {\r\n        this._target = target;\r\n        this._error = error;\r\n        this._returnedValue = returnedValue;\r\n    }\r\n\r\n    _getValueByPath (path) {\r\n        let result = null;\r\n        let epTarget = this._target;\r\n        let keyPaths = this._fallbackpath(path).split('.')\r\n        for (let i = 0, len = keyPaths.length; i < len; i++) {\r\n          result = result ? result[keyPaths[i]] : epTarget[keyPaths[i]];\r\n          if (typeof result === undefined) {\r\n              return result;\r\n          }\r\n        }\r\n        return result\r\n    }\r\n    _getValue (path) {\r\n        let result = null;\r\n        let epTarget = this._target;\r\n        let pResult = [];\r\n        let self = this;\r\n        if (typeof path === 'string' && path.length > 0) {\r\n            return this._getValueByPath(path);\r\n        } else if (nativeToString.call(path) === '[object Array]') {\r\n            path.forEach((singlePath, idx) => {\r\n                if (typeof singlePath === 'string') {\r\n                    result = self._getValueByPath(singlePath);\r\n                    pResult.push(result);\r\n                }\r\n            })\r\n            if (pResult.length === 0) {\r\n                return null;\r\n            }\r\n            return pResult;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    get (path) {\r\n        return path ? this._getValueByPath(path) : this._returnedValue;\r\n    }\r\n    _fallbackpath (path) {\r\n        if (typeof path !== 'string') {\r\n            return '';\r\n        }\r\n        return path;\r\n    }\r\n\r\n    // 扩展和设置值\r\n    _extend (ns, ns_string, ...rest) {\r\n        if (isObject(ns)) {\r\n            var current = ns;\r\n            var parts = ns_string.split('.');\r\n            var pl = parts.length;\r\n            for (let i = 0; i<pl; i++) {\r\n                if (typeof current[parts[i]] === 'undefined') {\r\n                    current[parts[i]] = {};\r\n                }\r\n                if (rest.length>0 && (i === pl-1)) {\r\n                    current = current[parts[i]] = rest[0];\r\n                } else {\r\n                    current = current[parts[i]];\r\n                }\r\n\r\n            } \r\n        }\r\n    }\r\n    _setOrDel (path, value) {\r\n        let fallbackPath = this._fallbackpath(path);\r\n        if (fallbackPath === '') {\r\n            if (typeof this._error === 'function') {\r\n                this._error(this._target, path);\r\n            }\r\n            return;\r\n        }\r\n        this._extend(this._target, fallbackPath, value);\r\n    }\r\n    set (path, value) {\r\n        if (isObject(path)) {\r\n            Object.keys(path).forEach((key, index) => {\r\n                this._setOrDel(key, path[key]);\r\n            })\r\n        } else {\r\n            this._setOrDel(path, value);\r\n        }\r\n    }\r\n\r\n    has (path) {\r\n       let returnedValue = this._getValueByPath(path);\r\n       if (!returnedValue) {\r\n           return false;\r\n       }\r\n       return true;\r\n    }\r\n\r\n    del(path) {\r\n        let self = this;\r\n        if (!path) {\r\n            return;\r\n        }\r\n        if (Array.isArray(path)) {\r\n            path.forEach((ph, index) => {\r\n                self._setOrDel(ph, void 0);\r\n            })\r\n        } else {\r\n            self._setOrDel(ph, void 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nconst jscalpel = ({ target, path, keys, dynamicKeys, prefix, callback, success, deep, plugins, error}, defaultOpts) => {\r\n    const compatCb = success || callback;\r\n    const enablePrefix = prefix ? true : false;\r\n    const deepCopy = (obj) => {\r\n        const returnObj = {};\r\n        let tempArr = [];\r\n        if (nativeToString.call(obj) === '[object Object]') {\r\n            Object.keys(obj).forEach((path, index) => {\r\n                if (Array.isArray(obj[path])) {\r\n                    obj[path].forEach((value, index) => {\r\n                        tempArr.push(value);\r\n                    });\r\n                    returnObj[path] = tempArr;\r\n                    tempArr = [];\r\n                } else if (nativeToString.call(obj[path] === '[object Object]')) {\r\n                    returnObj[path] = deepCopy(obj[path]);\r\n                }\r\n            });\r\n            return returnObj;\r\n        } else {\r\n            return obj;\r\n        }\r\n    }\r\n\r\n    const autoCompletePath = (path) => {\r\n        return (`${prefix && enablePrefix ? `${prefix}.${path}` : `${path}`}`);\r\n    }\r\n\r\n    const getValueByPath = function ({path, target, plugins, index}) {\r\n        let result = target\r\n        let parseingPaths = (autoCompletePath(path)).split('.')\r\n        for (let i = 0, len = parseingPaths.length; i < len; i++) {\r\n          result = result[parseingPaths[i]]\r\n          if (result === undefined) {\r\n              return result;\r\n          }\r\n        }\r\n        return result\r\n      }\r\n    \r\n      const executePlugins = ({ plugins, name, value }) => {\r\n          let willPluginInfo = {\r\n              value,\r\n              name\r\n          }\r\n          if (plugins && Array.isArray(plugins) && plugins.length) {\r\n            plugins.forEach((plugin, index) => {\r\n                plugin(willPluginInfo);\r\n            });\r\n          }\r\n\r\n      } \r\n    const getParameterNames = (fn) => {\r\n        const COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\n        const DEFAULT_PARAMS = /=[^,]+/mg;\r\n        const FAT_ARROWS = /=>.*$/mg;\r\n        const code = fn.toString()\r\n            .replace(COMMENTS, '')\r\n            .replace(FAT_ARROWS, '')\r\n            .replace(DEFAULT_PARAMS, '');\r\n\r\n        const result = code.slice(code.indexOf('(') + 1, code.indexOf(')'))\r\n            .match(/([^\\s,]+)/g);\r\n\r\n        return result === null\r\n            ? []\r\n            : result;\r\n    }\r\n\r\n    const getReturnedVal = (defaultValue, result, pResult) => {\r\n        if (typeof defaultValue !== 'undefined') {\r\n            return defaultValue;\r\n        } else {\r\n            return result || pResult;\r\n        }\r\n    }\r\n    //  try transform anything to object\r\n    const transformAnyToObj = (target) => {\r\n        let epTarget  = null;\r\n        try {\r\n            epTarget = typeof target === 'string' ? JSON.parse(target) : target;\r\n            if (deep) {\r\n                epTarget = deepCopy(epTarget);\r\n            }\r\n    \r\n            if (nativeToString.call(epTarget) !== '[object Object]' && !Array.isArray(epTarget)) {\r\n                typeof error === 'function' && error(epTarget);\r\n                return;\r\n            }\r\n        } catch (err) {\r\n            typeof error === 'function' && error(epTarget, err);\r\n            return;\r\n        }\r\n        return epTarget;\r\n    }\r\n\r\n    const getPaths = ({\r\n        path='',\r\n        keys,\r\n        dynamicKeys\r\n    }) => {\r\n        if (keys || typeof dynamicKeys === 'function') {\r\n            path = keys || dynamicKeys(prefix);\r\n        } else if (typeof path === 'function') {\r\n            path = path(prefix);\r\n        }\r\n        return path;\r\n    }\r\n    let defaultValue = null;\r\n    let result = null;\r\n    let willPluginInfo = {};\r\n    let epTarget = transformAnyToObj(target);\r\n    let pResult = [];\r\n    let cbParams = compatCb ? getParameterNames(compatCb) : [];\r\n    path = getPaths({\r\n        path,\r\n        keys,\r\n        dynamicKeys\r\n    })\r\n    if (typeof path === 'string' && path.length > 0) {\r\n        result = getValueByPath({path, target});\r\n        executePlugins({plugins, name: cbParams[0], value: result});\r\n        if (compatCb && typeof compatCb === 'function') {;\r\n            defaultValue = compatCb.call(null, result, epTarget, path, defaultOpts);\r\n        } else {\r\n            defaultValue = compatCb;\r\n        }\r\n    } else if (nativeToString.call(path) === '[object Array]') {\r\n        path.forEach((singlePath, idx) => {\r\n            if (typeof singlePath === 'string') {\r\n                result = getValueByPath({path: singlePath, target});\r\n                executePlugins({plugins, value: result, name: cbParams[idx]});\r\n                pResult.push(result);\r\n            }\r\n            result = null;\r\n        })\r\n        pResult.push(epTarget, path, defaultOpts);\r\n        if (compatCb && typeof compatCb === 'function') {\r\n            defaultValue = compatCb.apply(null, pResult);\r\n        } else {\r\n            defaultValue = compatCb;\r\n        }\r\n    }\r\n    if (typeof callback === 'function' || typeof success === 'function') {\r\n        return getReturnedVal(defaultValue, result, pResult.slice(0,-3));\r\n    }\r\n    return new JscalpelCore({\r\n        target: epTarget,\r\n        error\r\n    })\r\n}\r\n\r\nexport default jscalpel;\r\n\r\nexport {\r\n    jscalpelType,\r\n    jscalpelLogic\r\n}","const jscalpelType = ({\r\n    value,\r\n    name\r\n}) => {\r\n    const simpleTypes = ['string', 'undefined', 'function', 'number', 'boolean'];\r\n    if (simpleTypes.indexOf(typeof value)!== -1 ) {\r\n        return {\r\n            value,\r\n            type: typeof value\r\n        }\r\n    }\r\n    if (value + '' === 'null') {\r\n        return {\r\n            value,\r\n            type: 'null'\r\n        }\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return {\r\n            value,\r\n            type: 'array',\r\n            length: value.length\r\n        }\r\n    }\r\n    if (Object.prototype.toString.call(value) === '[object Object]') {\r\n        return {\r\n            value,\r\n            name,\r\n            type: 'object',\r\n            keys: Object.keys(value),\r\n            values: Object.values(value)\r\n        }\r\n    }\r\n}\r\n\r\nexport default jscalpelType;","import jscalpel from '../index';\r\nconst jscalpelLogic = (logicMap) => ({\r\n    value,\r\n    name\r\n}) => {\r\n    if (logicMap[name]) {\r\n        jscalpel({\r\n            target: logicMap,\r\n            prefix: `${name}`,\r\n            path: ['match', 'success'],\r\n            callback: (match, success) => {\r\n                match({value, name}) && success({value, name});\r\n                return value;\r\n            }\r\n        });\r\n    }\r\n    return value;\r\n};\r\nexport default jscalpelLogic;\r\n"],"names":["nativeToString","Object","prototype","toString","isObject","path","call","JscalpelCore","target","returnedValue","error","_target","_error","_returnedValue","result","epTarget","this","keyPaths","_fallbackpath","split","i","len","length","undefined","pResult","self","_getValueByPath","forEach","singlePath","idx","push","ns","ns_string","current","parts","pl","value","fallbackPath","_extend","keys","key","index","_setOrDel","Array","isArray","ph","jscalpel","defaultOpts","dynamicKeys","prefix","callback","success","deep","plugins","compatCb","enablePrefix","deepCopy","obj","returnObj","tempArr","autoCompletePath","getValueByPath","parseingPaths","executePlugins","name","willPluginInfo","plugin","defaultValue","JSON","parse","err","transformAnyToObj","cbParams","fn","COMMENTS","DEFAULT_PARAMS","FAT_ARROWS","code","replace","slice","indexOf","match","getParameterNames","getPaths","apply","getReturnedVal","values","logicMap"],"mappings":"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"}